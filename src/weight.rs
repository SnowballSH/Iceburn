use crate::chess::{Chess, Color, Setup, Role};

pub const MATERIAL_OPENING: [i32; 6] = [110, 450, 470, 646, 1170, 20000];
pub const MATERIAL_ENDGAME: [i32; 6] = [140, 582, 617, 928, 1808, 20000];
pub const INF_SCORE: i32 = i32::MAX - 10000;

pub fn is_checkmate(value: i32) -> bool {
    2 * value.abs() >= INF_SCORE
}

pub const PSQ: [[i32; 64]; 7] = [
    [
        0, 0, 0, 0, 0, 0, 0, 0, 50, 50, 50, 50, 50, 50, 50, 50, 10, 10, 20, 30, 30, 20, 10, 10, 5,
        5, 10, 25, 25, 10, 5, 5, 0, 0, 0, 20, 20, 0, 0, 0, 5, -5, -10, 0, 0, -10, -5, 5, 5, 10, 10,
        -20, -20, 10, 10, 5, 0, 0, 0, 0, 0, 0, 0, 0,
    ],
    [
        -50, -40, -30, -30, -30, -30, -40, -50, -40, -20, 0, 0, 0, 0, -20, -40, -30, 0, 10, 15, 15,
        10, 0, -30, -30, 5, 15, 20, 20, 15, 5, -30, -30, 0, 15, 20, 20, 15, 0, -30, -30, 5, 10, 15,
        15, 10, 5, -30, -40, -20, 0, 5, 5, 0, -20, -40, -50, -40, -30, -30, -30, -30, -40, -50,
    ],
    [
        -20, -10, -10, -10, -10, -10, -10, -20, -10, 0, 0, 0, 0, 0, 0, -10, -10, 0, 5, 10, 10, 5,
        0, -10, -10, 5, 5, 10, 10, 5, 5, -10, -10, 0, 10, 10, 10, 10, 0, -10, -10, 10, 10, 10, 10,
        10, 10, -10, -10, 5, 0, 0, 0, 0, 5, -10, -20, -10, -10, -10, -10, -10, -10, -20,
    ],
    [
        0, 0, 0, 0, 0, 0, 0, 0, 5, 10, 10, 10, 10, 10, 10, 5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0,
        0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0,
        -5, 0, 0, 0, 5, 5, 0, 0, 0,
    ],
    [
        -20, -10, -10, -5, -5, -10, -10, -20, -10, 0, 0, 0, 0, 0, 0, -10, -10, 0, 5, 5, 5, 5, 0,
        -10, -5, 0, 5, 5, 5, 5, 0, -5, 0, 0, 5, 5, 5, 5, 0, -5, -10, 5, 5, 5, 5, 5, 0, -10, -10, 0,
        5, 0, 0, 0, 0, -10, -20, -10, -10, -5, -5, -10, -10, -20,
    ],
    [
        -30,-40,-40,-50,-50,-40,-40,-30,
        -30,-40,-40,-50,-50,-40,-40,-30,
        -30,-40,-40,-50,-50,-40,-40,-30,
        -30,-40,-40,-50,-50,-40,-40,-30,
        -20,-30,-30,-40,-40,-30,-30,-20,
        -10,-20,-20,-20,-20,-20,-20,-10,
        20, 20,  0,  0,  0,  0, 20, 20,
        20, 30, 10,  0,  0, 10, 30, 20
    ],
    [
        -50, -40, -30, -20, -20, -30, -40, -50, -30, -20, -10, 0, 0, -10, -20, -30, -30, -10, 20,
        30, 30, 20, -10, -30, -30, -10, 30, 40, 40, 30, -10, -30, -30, -10, 30, 40, 40, 30, -10,
        -30, -30, -10, 20, 30, 30, 20, -10, -30, -30, -30, 0, 0, 0, 0, -30, -30, -50, -30, -30,
        -30, -30, -30, -30, -50,
    ],
];

pub fn fast_eval(board: &Chess) -> i32 {
    let mut score = 0;
    for (sq, p) in board.board().pieces() {
        score += MATERIAL_OPENING[p.role as usize - 1] * (p.color as i32 * 2 - 1);
        score += PSQ[p.role as usize - 1][if p.color == Color::White {
            sq as usize
        } else {
            sq as usize ^ 56
        }] * (p.color as i32 * 2 - 1)
    }
    score * ((board.turn() as i32 * 2 - 1) as f64 * 1.7) as i32
}

pub fn fast_eval_endgame(board: &Chess) -> i32 {
    let mut score = 0;
    for (sq, p) in board.board().pieces() {
        score += MATERIAL_ENDGAME[p.role as usize - 1] * (p.color as i32 * 2 - 1);
        score += PSQ[if p.role == Role::King {
            6
        } else {
            p.role as usize - 1
        }][if p.color == Color::White {
            sq as usize
        } else {
            sq as usize ^ 56
        }] * (p.color as i32 * 2 - 1)
    }
    score * (board.turn() as i32 * 2 - 1) * 3
}
